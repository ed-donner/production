name: Deploy Digital Twin

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - test
          - prod

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    name: Deploy to ${{ github.event.inputs.environment || 'dev' }}
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: github-actions-deploy
          aws-region: ${{ secrets.DEFAULT_AWS_REGION }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install uv
        run: |
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false  # Important: disable wrapper to get raw outputs

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Setup Terraform Backend
        run: |
          set -e

          AWS_ACCOUNT_ID=${{ secrets.AWS_ACCOUNT_ID }}
          AWS_REGION=${{ secrets.DEFAULT_AWS_REGION }}
          BUCKET_NAME="twin-terraform-state-${AWS_ACCOUNT_ID}"
          TABLE_NAME="twin-terraform-locks"

          echo "üîß Checking Terraform backend infrastructure..."

          # Check if S3 bucket exists
          if aws s3 ls "s3://${BUCKET_NAME}" 2>&1 | grep -q 'NoSuchBucket'; then
            echo "üì¶ Creating S3 bucket: ${BUCKET_NAME}"
            aws s3api create-bucket \
              --bucket "${BUCKET_NAME}" \
              --region "${AWS_REGION}" \
              --create-bucket-configuration LocationConstraint="${AWS_REGION}"

            # Enable versioning
            aws s3api put-bucket-versioning \
              --bucket "${BUCKET_NAME}" \
              --versioning-configuration Status=Enabled

            # Enable encryption
            aws s3api put-bucket-encryption \
              --bucket "${BUCKET_NAME}" \
              --server-side-encryption-configuration '{
                "Rules": [{
                  "ApplyServerSideEncryptionByDefault": {
                    "SSEAlgorithm": "AES256"
                  }
                }]
              }'

            echo "‚úÖ S3 bucket created and configured"
          else
            echo "‚úÖ S3 bucket already exists: ${BUCKET_NAME}"
          fi

          # Check if DynamoDB table exists
          if ! aws dynamodb describe-table --table-name "${TABLE_NAME}" --region "${AWS_REGION}" 2>&1 >/dev/null; then
            echo "üîí Creating DynamoDB table: ${TABLE_NAME}"
            aws dynamodb create-table \
              --table-name "${TABLE_NAME}" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --region "${AWS_REGION}"

            echo "‚è≥ Waiting for table to be active..."
            aws dynamodb wait table-exists \
              --table-name "${TABLE_NAME}" \
              --region "${AWS_REGION}"

            echo "‚úÖ DynamoDB table created"
          else
            echo "‚úÖ DynamoDB table already exists: ${TABLE_NAME}"
          fi

          echo "üéâ Terraform backend infrastructure ready"

      - name: Build Lambda Package
        run: |
          echo "üì¶ Building Lambda deployment package..."
          cd backend
          uv run deploy.py
          cd ..
          echo "‚úÖ Lambda package built successfully"
          echo "üìç Verifying package location:"
          ls -lh backend/lambda-deployment.zip

      - name: Check DNS and Certificate Setup (Prod Only)
        if: github.event.inputs.environment == 'prod'
        run: |
          set -e

          ENV="${{ github.event.inputs.environment || 'dev' }}"
          DOMAIN="quercus-ai.com"

          echo "üîç Checking DNS and certificate setup for production deployment..."

          # Verify Lambda package exists before initializing Terraform
          echo "üîç Verifying Lambda package exists..."
          ls -lh backend/lambda-deployment.zip

          # Initialize Terraform to check state
          cd terraform
          echo "üìÇ Current directory: $(pwd)"
          echo "üîç Checking Lambda package from terraform directory..."
          ls -lh ../backend/lambda-deployment.zip
          AWS_ACCOUNT_ID=${{ secrets.AWS_ACCOUNT_ID }}
          AWS_REGION=${{ secrets.DEFAULT_AWS_REGION }}

          terraform init -input=false \
            -backend-config="bucket=twin-terraform-state-${AWS_ACCOUNT_ID}" \
            -backend-config="key=${ENV}/terraform.tfstate" \
            -backend-config="region=${AWS_REGION}" \
            -backend-config="dynamodb_table=twin-terraform-locks" \
            -backend-config="encrypt=true"

          # Create or select workspace immediately after init
          if ! terraform workspace list | grep -q "$ENV"; then
            terraform workspace new "$ENV"
          else
            terraform workspace select "$ENV"
          fi

          # Check if Route53 hosted zone exists
          ZONE_ID=$(aws route53 list-hosted-zones --query "HostedZones[?Name=='${DOMAIN}.'].Id" --output text | sed 's/\/hostedzone\///')

          if [ -z "$ZONE_ID" ]; then
            echo "üîß First-time production deployment detected"
            echo "üìã Creating DNS infrastructure (Route53 zone and ACM certificate)..."

            # Apply only DNS and certificate resources
            terraform apply \
              -var-file=prod.tfvars \
              -var="project_name=twin" \
              -var="environment=prod" \
              -target=aws_route53_zone.root[0] \
              -target=aws_acm_certificate.site[0] \
              -target='aws_route53_record.site_validation["quercus-ai.com"]' \
              -target='aws_route53_record.site_validation["www.quercus-ai.com"]' \
              -auto-approve

            echo ""
            echo "‚ö†Ô∏è  DEPLOYMENT PAUSED - ACTION REQUIRED"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo ""
            echo "üìù Step 1: Update nameservers at your domain registrar (Namecheap)"
            echo ""
            echo "   Use these nameservers:"
            terraform output -json route53_nameservers | jq -r '.[]' | sed 's/^/   ‚Üí /'
            echo ""
            echo "üìù Step 2: Wait 5-30 minutes for DNS propagation"
            echo ""
            echo "   Verify with: dig NS ${DOMAIN} +short"
            echo ""
            echo "üìù Step 3: Wait for ACM certificate validation (happens automatically)"
            echo ""
            echo "   Check status with:"
            echo "   aws acm list-certificates --region us-east-1 \\"
            echo "     --query \"CertificateSummaryList[?DomainName=='${DOMAIN}'].Status\""
            echo ""
            echo "üìù Step 4: Re-run this workflow once certificate shows 'ISSUED'"
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            exit 1
          fi

          echo "‚úÖ Route53 hosted zone exists (ID: $ZONE_ID)"

          # Check ACM certificate status
          CERT_ARN=$(aws acm list-certificates --region us-east-1 \
            --query "CertificateSummaryList[?DomainName=='${DOMAIN}'].CertificateArn" \
            --output text)

          if [ -z "$CERT_ARN" ]; then
            echo "‚ùå ACM certificate not found"
            echo "‚ö†Ô∏è  This shouldn't happen. The certificate should have been created in the first run."
            echo "üí° Try destroying and redeploying, or create the certificate manually."
            exit 1
          fi

          CERT_STATUS=$(aws acm describe-certificate \
            --certificate-arn "$CERT_ARN" \
            --region us-east-1 \
            --query 'Certificate.Status' \
            --output text)

          echo "üìú Certificate status: $CERT_STATUS"

          if [ "$CERT_STATUS" != "ISSUED" ]; then
            echo ""
            echo "‚ö†Ô∏è  DEPLOYMENT BLOCKED - Certificate Not Validated"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo ""
            echo "The ACM certificate is still pending validation."
            echo ""
            echo "Current status: $CERT_STATUS"
            echo ""
            echo "üìù Next steps:"
            echo ""
            echo "1. Verify nameservers are updated at your registrar:"
            echo "   dig NS ${DOMAIN} +short"
            echo ""
            echo "2. Wait for DNS propagation (can take up to 48 hours, usually 5-30 minutes)"
            echo ""
            echo "3. Certificate validation happens automatically once DNS propagates"
            echo ""
            echo "4. Re-run this workflow once certificate status is 'ISSUED'"
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            exit 1
          fi

          echo "‚úÖ ACM certificate is validated and issued"
          echo "üöÄ Proceeding with full deployment..."
          cd ..

      - name: Run Deployment Script
        run: |
          # Set environment variables for the script
          export AWS_ACCOUNT_ID=${{ secrets.AWS_ACCOUNT_ID }}
          export DEFAULT_AWS_REGION=${{ secrets.DEFAULT_AWS_REGION }}
          
          # Make script executable and run it
          chmod +x scripts/deploy.sh
          ./scripts/deploy.sh ${{ github.event.inputs.environment || 'dev' }}
        env:
          AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
          
      - name: Get Deployment URLs
        id: deploy_outputs
        working-directory: ./terraform
        run: |
          echo "cloudfront_url=$(terraform output -raw cloudfront_url)" >> $GITHUB_OUTPUT
          echo "api_url=$(terraform output -raw api_gateway_url)" >> $GITHUB_OUTPUT
          echo "frontend_bucket=$(terraform output -raw s3_frontend_bucket)" >> $GITHUB_OUTPUT

      - name: Invalidate CloudFront
        run: |
          DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Origins.Items[?DomainName=='${{ steps.deploy_outputs.outputs.frontend_bucket }}.s3-website-${{ secrets.DEFAULT_AWS_REGION }}.amazonaws.com']].Id | [0]" \
            --output text)
          
          if [ "$DISTRIBUTION_ID" != "None" ] && [ -n "$DISTRIBUTION_ID" ]; then
            aws cloudfront create-invalidation \
              --distribution-id $DISTRIBUTION_ID \
              --paths "/*"
          fi

      - name: Deployment Summary
        run: |
          echo "‚úÖ Deployment Complete!"
          echo "üåê CloudFront URL: ${{ steps.deploy_outputs.outputs.cloudfront_url }}"
          echo "üì° API Gateway: ${{ steps.deploy_outputs.outputs.api_url }}"
          echo "ü™£ Frontend Bucket: ${{ steps.deploy_outputs.outputs.frontend_bucket }}"
          